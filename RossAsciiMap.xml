<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
	 name="RossAsciiMap"
	 author="Ross Grams"
	 purpose="ASCII-map miniwindow"
	 id="4045bd321bb34f7bc51a3ce8"
	 language="Lua"
	 save_state="y"
	 date_written="2019-02-22 13:38:17"
	 requires="5.05"
	 version="1.1"
	 >
</plugin>

<script>
	<![CDATA[

local SELF_ID = GetPluginID()
local GMCP_INTERFACE_ID = "c190b5fc9e83b05d8de996c3"
local winID = SELF_ID .. "RossAsciiMap"

-- Get require path for modules - relative path from mushclient directory.
local mushClientPath, pluginPath = GetInfo(66), GetPluginInfo(SELF_ID, 20)
local requirePath = pluginPath:gsub(mushClientPath, ""):gsub("\\", ".")

local RGBToInt = require (requirePath .. "RGBToInt")
local window = require (requirePath .. "window")
local parseMDT = require(requirePath .. "MapDoorTextParser")

-- Settings:
--------------------------------------------------
local COLORS = {
	background = 0,
	border = 12632256,
	Normal = RGBToInt(192),
	Yellow = RGBToInt(255, 255, 0),
	Red = RGBToInt(255, 0, 0),
	Green = RGBToInt(0, 255, 0),
	Cyan = RGBToInt(0, 255, 255),
	Blue = RGBToInt(0, 0, 255),
	Magenta = RGBToInt(255, 0, 255),
	White = RGBToInt(255),
	Black = RGBToInt(),
	Desert = 34815,
}
local DEFAULT_COLORS = {}
for k,v in pairs(COLORS) do  DEFAULT_COLORS[k] = v  end
local fontFamily = "fixedsys"
local fontSize = 9 -- NOTE: FixedSys only comes in this size.
local lineSpacing = 0
local charSpacing = 0

-- Other Vars:
--------------------------------------------------
local winRect = {x = 800, y = 0, width = 200, height = 200, z = 0}
local winLocked = false
local fontID = "font" -- Not the font name, just the ID it's registered to for our window.
local fontHeight
local fontCharWidth
local fontMaxCharWidth -- For the rect to draw each character within.
local loadFont -- Upvalue for function.

local playerY, playerX = 1, 1
local mapLines = {}
local colorChangesAt = {}
local mxpColorRegex = rex.new("MXP<(.+?)MXP>")
local hexRegex = rex.new(".*? (#[0-9a-f]{6})") -- MXP<C #ff8700MXP>
local lastPacket -- Save last raw packet string to disk so we can show something on load.

-- Loading & Saving Settings:
--------------------------------------------------
local function toboolean(v) -- Convert a value to a boolean. Always returns a boolean.
	if v == nil then  return false
	elseif v == false or v == "false" then  return false  end
	return true -- Anything other than nil, false, or "false" ==> true.
end

local function loadVar(name) -- Returns nil instead of an empty string.
	local v = GetVariable(name)
	if v == "" then  return nil  end
	return v
end

local function loadSettings()
	for k,v in pairs(winRect) do
		winRect[k] = tonumber(GetVariable("window_" .. k)) or v
	end
	winLocked = toboolean(GetVariable("windowLocked"))
	lastPacket = loadVar("lastPacket")
	fontFamily = loadVar("fontFamily") or fontFamily
	fontSize = loadVar("fontSize") or fontSize
	for colorName in pairs(COLORS) do
		COLORS[colorName] = tonumber(loadVar("color_" .. colorName)) or DEFAULT_COLORS[colorName]
	end
end

local function saveVar(name, val, nilVal)
	if val == nil then  val = nilVal or false  end
	SetVariable(name, tostring(val))
end

local function saveSettings()
	for k,v in pairs(winRect) do
		saveVar("window_" .. k, v)
	end
	winLocked = window.getLocked(winID)
	saveVar("windowLocked", winLocked)
	if lastPacket then  saveVar("lastPacket", lastPacket)  end
	saveVar("fontFamily", fontFamily, "fixedsys")
	saveVar("fontSize", fontSize, 9)
	for colorName in pairs(COLORS) do
		saveVar("color_" .. colorName, COLORS[colorName])
	end
end

function OnPluginSaveState()
	saveSettings()
end

-- Right-Click Menu Handling:
--------------------------------------------------
local function pickFont()
	local fnt = utils.fontpicker(fontFamily, fontSize)
	if fnt then
		fontFamily, fontSize = fnt.name, fnt.size
		loadFont(winID, fontID, fontFamily, fontSize)
		window.draw(winID)
	end
end

local function pickColor(colorName)
	local result = PickColour(COLORS[colorName])
	if result ~= -1 then
		COLORS[colorName] = result
		if lastPacket then
			onGMCPReceived("room.map", lastPacket)
			window.draw(winID)
		end
	end
end

local function resetColorToDefault(colorName)
	COLORS[colorName] = DEFAULT_COLORS[colorName]
	if lastPacket then
		onGMCPReceived("room.map", lastPacket)
		window.draw(winID)
	end
end

local menuItems = {}

local function menuItem(text, fn, ...)
	table.insert(menuItems, {text, fn, ...})
end

menuItem("Set font...", pickFont)
local colorNames = {"background", "border", "Normal", "Yellow", "Red", "Green", "Cyan", "Blue", "Desert", "Magenta", "White", "Black"}
menuItem(">Colors:")
menuItem(">defaults:")
for i,colorName in ipairs(colorNames) do
	menuItem("Reset "..colorName.." to default", resetColorToDefault, colorName)
end
menuItem("<")
menuItem("-")
for i,colorName in ipairs(colorNames) do
	menuItem("Set "..colorName.." color...", pickColor, colorName)
end
menuItem("<")

local menuItemList = {} -- List of button texts for adding to window.
for i,v in ipairs(menuItems) do  table.insert(menuItemList, v[1])  end

local function menuItemClicked(winID, i, prefix, item)
	local data = menuItems[i]
	if data then
		local fn = data[2]
		fn(unpack(data, 3))
	end
end

-- GMCP Parsing:
--------------------------------------------------
local function processColorCodes(startPos, line, lineIdx)
	-- Strip out color codes and record at which character index the color changes.
	local startI, endI, captures = mxpColorRegex:match(line, startPos)
	if endI then
		local colorName = captures[1]

		if colorName == "Yellow" then -- This is the line the player is on.
			playerX, playerY = startI, lineIdx
		end

		-- Convert color string into an integer RGB value.
		local colorInt
		if COLORS[colorName] then
			colorInt = COLORS[colorName]
		else
			local _s, _e, hexCaptures = hexRegex:match(colorName)
			if hexCaptures then
				if hexCaptures[1] == "#ff8700" then
					colorName = "Desert"
					colorInt = COLORS[colorName]
				else
					colorInt = ColourNameToRGB(hexCaptures[1]) -- ColourNameToRGB will convert hex colors.
				end
			else
				Note("RossAsciiMap - Unrecognized color code: '", string.sub(line, startI, endI), "'.")
				colorInt = COLORS.Normal
			end
		end
		colorChangesAt[lineIdx] = colorChangesAt[lineIdx] or {}
		colorChangesAt[lineIdx][startI] = colorInt

		-- Cut color code chunk out of map string.
		local pre = string.sub(line, 1, startI - 1)
		local post = string.sub(line, endI + 1)
		line = pre .. post
	end
	-- We're removing everything from startI to endI, so our startI should
	-- also be the start for the next match.
	return startI, line
end

--[[
-- Output from MUD:
"\u001b[3z\u001b[4zMXP<RedMXP>+\u001b[3z     \u001b[3z\u001b[4zMXP<RedMXP>+\u001b[3z   \n\u001b[3z\u001b[4zMXP<GreenMXP>&\u001b[3z-\u001b[3z\u001b[4zMXP<CyanMXP>*\u001b[3z-\u001b[3z\u001b[4zMXP<YellowMXP>@\u001b[3z-\u001b[3z\u001b[4zMXP<GreenMXP>$\u001b[3z   \n       \u001b[3z\\\u001b[3z  \n        \u001b[3z\u001b[4zMXP<CyanMXP>*\u001b[3z-\u001b[3z\n"
-- Desired Result:
+     +
&-*-@-$
       \
        *-
--]]

local curMDTData

local getCountRegex = rex.new("^(\\d+)")

local function scoreMDTRooms(data)
	for i,room in ipairs(data) do
		local score = 0
		for i,entStr in ipairs(room.entities) do
			local _, _, capt = getCountRegex:match(entStr)
			local count = capt and capt[1] or 1
			score = score + count
		end
		room.score = score
	end
end

-- Make a 2D array of room scores with relative coordinates from player.
local function makeMDTArraymap(data)
	local map = {}
	for i,room in ipairs(data) do
		local x, y = room.dx, room.dy
		map[y] = map[y] or {}
		map[y][x] = room.score or 1
	end
	data.scoreMap = map
end

function onGMCPReceived(message, dataStr)
	if message == "room.writtenmap" then
		curMDTData = parseMDT(dataStr)
		scoreMDTRooms(curMDTData)
		makeMDTArraymap(curMDTData)
		window.draw(winID) -- writtenmap is sent second, so draw here.
	elseif message == "room.map" then
		-- Map is colored with MXP color codes. First strip out the extra junk, then split into lines and process the color codes.
		lastPacket = dataStr
		local map = dataStr
		map = string.sub(map, 2, -2) -- remove surrounding quotes ("").
		map = string.gsub(map, "\\u001b%[4z", "") -- Remove ANSI codes before MXP colors.
		map = string.gsub(map, "MXP<[\\/]-send.-MXP>", "") -- remove MXP links, if any (not colors).
		-- Replace ANSI reset code with a fake MXP color tag, which the next step will pick up.
		map = string.gsub(map, "\\u001b%[3z", "MXP<NormalMXP>")
		-- Un-escape actual map characters.
		map = string.gsub(map, "\\\\", "\\") -- change \\ to \.
		map = string.gsub(map, "\\\/", "\/") -- change \/ to /.

		for i=#mapLines,1,-1 do -- Clear old lists.
			mapLines[i] = nil
			colorChangesAt[i] = nil
		end

		for line in string.gmatch(map, "(.-)\\n") do -- Split map up into lines.
			table.insert(mapLines, line)
		end

		for lineIdx,line in ipairs(mapLines) do
			local startPos = 1
			while startPos do
				startPos, line = processColorCodes(startPos, line, lineIdx)
			end
			mapLines[lineIdx] = line -- Update line after stripping out color codes.
		end
	end
end

-- Drawing:
--------------------------------------------------
local function drawWindow()
	winRect.width = WindowInfo(winID, 3)
	winRect.height = WindowInfo(winID, 4)
	WindowRectOp(winID, 2, 0, 0, winRect.width, winRect.height, COLORS.background) -- Clear/Fill Background
	WindowRectOp(winID, 1, 0, 0, winRect.width, winRect.height, COLORS.border) -- Draw Border

	local gridX, gridY = fontCharWidth + charSpacing, fontHeight + lineSpacing

	local mapHalfWidth = (playerX - 0.5) * gridX
	local mapHalfHeight = (playerY - 0.5) * gridY

	local ox, oy = winRect.width/2 - mapHalfWidth, winRect.height/2 - mapHalfHeight

	local baseCol = COLORS.Normal
	local color = baseCol
	for lineIdx,line in ipairs(mapLines) do
		local x, y = ox, oy + (lineIdx - 1)*gridY
		color = baseCol

		for charIdx=1,string.len(line) do
			if colorChangesAt[lineIdx] and colorChangesAt[lineIdx][charIdx] then
				color = colorChangesAt[lineIdx][charIdx]
				if type(color) ~= "number" then
					Note("RossAsciiMap - Weird color value in colorChangesAt: ", colorChangesAt[lineIdx][charIdx])
					color = COLORS.Normal
				end
			end
			local char = string.sub(line, charIdx, charIdx)
			if char ~= " " then
				WindowText(winID, fontID, char, x, y, x+fontMaxCharWidth, y+gridY, color)
			end
			x = x + gridX
		end
	end

	-- Draw room scores.
	if curMDTData then
		local ox, oy = winRect.width/2, winRect.height/2 -- Start from player pos, center of window.
		for dy,row in pairs(curMDTData.scoreMap) do
			for dx,score in pairs(row) do
				-- Double dx and dy because rooms are every-other line on the ASCII map.
				local x, y = ox + dx*2*gridX, oy - dy*2*gridY -- Subtract dy because we draw in +y = down coordinates.
				x = x + 2
				WindowText(winID, fontID, score, x, y, x+fontMaxCharWidth, y+gridY, COLORS.Red)
			end
		end
	end
end

-- Setup & Breakdown:
--------------------------------------------------
function loadFont(winID, fontID, fontFamily, fontSize) -- Is local--upvalue defined above.
	WindowFont(winID, fontID, fontFamily, fontSize, nil, nil, nil, nil, 0)
	fontHeight = WindowFontInfo(winID, fontID, 1)
	fontCharWidth = WindowFontInfo(winID, fontID, 6) -- Average character width.
	fontMaxCharWidth = WindowFontInfo(winID, fontID, 7) -- Max character width.
end

local function init()
	CallPlugin(GMCP_INTERFACE_ID, "subscribe", SELF_ID, "onGMCPReceived", "room.map", "room.writtenmap")
	loadSettings()
	window.new(
		winID, winRect.x, winRect.y, winRect.width, winRect.height, winRect.z,
		nil, nil, nil, true, winLocked, menuItemClicked, drawWindow
	)
	window.addMenuItems(winID, 1, menuItemList)
	if lastPacket then  onGMCPReceived("room.map", lastPacket)  end
	loadFont(winID, fontID, fontFamily, fontSize)
	window.draw(winID)
end

local function final()
	winRect.x, winRect.y, winRect.width, winRect.height, winRect.z = window.getRect(winID)
	winLocked = window.getLocked(winID)
	WindowDelete(winID)
	CallPlugin(GMCP_INTERFACE_ID, "unsubscribe", SELF_ID, "room.map", "room.writtenmap")
end

function OnPluginInstall()  init()  end
function OnPluginEnable()  init()  end
function OnPluginClose()  final()  end
function OnPluginDisable()  final() end

	]]>
</script>

</muclient>
