<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
	 name="RossAsciiMap"
	 author="Ross Grams"
	 purpose="ASCII-map miniwindow"
	 id="4045bd321bb34f7bc51a3ce8"
	 language="Lua"
	 save_state="y"
	 date_written="2019-02-22 13:38:17"
	 requires="5.05"
	 version="1.1"
	 >
</plugin>

<script>
	<![CDATA[

require "json"

local SELF_ID = GetPluginID()
local GMCP_INTERFACE_ID = "c190b5fc9e83b05d8de996c3"
local winID = SELF_ID .. "RossAsciiMap"

-- Get require path for modules - relative path from mushclient directory.
local mushClientPath, pluginPath = GetInfo(66), GetPluginInfo(SELF_ID, 20)
local requirePath = pluginPath:gsub(mushClientPath, ""):gsub("\\", ".")

local RGBToInt = require (requirePath .. "RGBToInt")
local window = require (requirePath .. "window")
local parseMDT = require(requirePath .. "MapDoorTextParser")

-- Settings:
--------------------------------------------------
local COLORS = {
	background = 0,
	border = 12632256,
	Normal = RGBToInt(192),
	Yellow = RGBToInt(255, 255, 0),
	Red = RGBToInt(255, 0, 0),
	Green = RGBToInt(0, 255, 0),
	Cyan = RGBToInt(0, 255, 255),
	Blue = RGBToInt(0, 0, 255),
	Magenta = RGBToInt(255, 0, 255),
	White = RGBToInt(255),
	Desert = 34815,
}
local DEFAULT_COLORS = {}
for k,v in pairs(COLORS) do  DEFAULT_COLORS[k] = v  end
local fontFamily = "fixedsys"
local fontSize = 9 -- NOTE: FixedSys only comes in this size.
local spacingX, spacingY = 0, 0

-- Other Vars:
--------------------------------------------------
local winRect = {x = 800, y = 0, width = 200, height = 200, z = 0}
local winLocked = false
local fontID = "font" -- Not the font name, just the ID it's registered to for our window.
local fontHeight
local fontCharWidth
local fontMaxCharWidth -- For the rect to draw each character within.
local loadFont -- Upvalue for function.

local playerY, playerX = 1, 1
local mapLines = {}
local colorChangesAt = {}
local mxpColorRegex = rex.new("MXP<(.+?)MXP>")
local hexRegex = rex.new(".*? (#[0-9a-f]{6})") -- MXP<C #ff8700MXP>
local lastMapPacket, lastMDTPacket-- Save last raw packet string to disk so we can show something on load.

local MDTIndicatorsEnabled = true
local entityFilters = {}
local CASE_INSENSITIVE = rex.flags().CASELESS

-- Loading & Saving Settings:
--------------------------------------------------
local function toboolean(v) -- Convert a value to a boolean. Always returns a boolean.
	if v == nil then  return false
	elseif v == false or v == "false" then  return false  end
	return true -- Anything other than nil, false, or "false" ==> true.
end

local function loadVar(name) -- Returns nil instead of an empty string.
	local v = GetVariable(name)
	if v == "" then  return nil  end
	return v
end

local function loadSettings()
	for k,v in pairs(winRect) do
		winRect[k] = tonumber(GetVariable("window_" .. k)) or v
	end
	winLocked = toboolean(GetVariable("windowLocked"))
	lastMapPacket = loadVar("lastMapPacket")
	lastMDTPacket = loadVar("lastMDTPacket")
	fontFamily = loadVar("fontFamily") or fontFamily
	fontSize = loadVar("fontSize") or fontSize
	spacingX = loadVar("spacingX") or spacingX
	spacingY = loadVar("spacingY") or spacingY
	for colorName in pairs(COLORS) do
		COLORS[colorName] = tonumber(loadVar("color_" .. colorName)) or DEFAULT_COLORS[colorName]
	end

	local MDTEnabled = loadVar("MDTIndicatorsEnabled")
	if MDTEnabled then  MDTIndicatorsEnabled = toboolean(MDTEnabled)  end

	local filters = loadVar("entityFilters")
	if filters then
		entityFilters = json.decode(filters)
		for i,f in ipairs(entityFilters) do
			local regexFlags = f.doesIgnoreCase and CASE_INSENSITIVE or nil
			f.regex = rex.new(f.pattern, regexFlags)
		end
	end
end

local function saveVar(name, val, nilVal)
	if val == nil then  val = nilVal or false  end
	SetVariable(name, tostring(val))
end

local function saveSettings()
	for k,v in pairs(winRect) do
		saveVar("window_" .. k, v)
	end
	winLocked = window.getLocked(winID)
	saveVar("windowLocked", winLocked)
	if lastMapPacket then  saveVar("lastMapPacket", lastMapPacket)  end
	if lastMDTPacket then  saveVar("lastMDTPacket", lastMDTPacket)  end
	saveVar("fontFamily", fontFamily, "fixedsys")
	saveVar("fontSize", fontSize, 9)
	saveVar("spacingX", spacingX, 0)
	saveVar("spacingY", spacingY, 0)
	for colorName in pairs(COLORS) do
		saveVar("color_" .. colorName, COLORS[colorName])
	end

	saveVar("MDTIndicatorsEnabled", MDTIndicatorsEnabled)

	-- Save custom entity filters.
	if next(entityFilters) then
		-- Can't save regex object, so make a copy of the filters without it.
		local saveData = {}
		local filterPropsToSave = {"pattern", "score", "group", "keepEvaluating", "doesIgnoreCase"}
		for i,f in ipairs(entityFilters) do
			local v = {}
			for _,prop in ipairs(filterPropsToSave) do  v[prop] = f[prop]  end
			saveData[i] = v
		end
		saveVar("entityFilters", json.encode(saveData))
	end
end

function OnPluginSaveState()
	saveSettings()
end

local function refresh()
	if lastMapPacket then
		onGMCPReceived("room.map", lastMapPacket)
	end
	if lastMDTPacket and MDTIndicatorsEnabled then
		onGMCPReceived("room.writtenmap", lastMDTPacket)
	else
		window.draw(winID)
	end
end

-- Living Thing Filter Editing:
--------------------------------------------------
local curMDTData
local getCountRegex = rex.new("^(\\d+)")

local function addFilter(pattern, score, group, keepEvaluating, doesIgnoreCase)
	local regexFlags = doesIgnoreCase and CASE_INSENSITIVE or nil
	local filter = {
		regex = rex.new(pattern, regexFlags),
		pattern = pattern,
		score = score,
		group = group,
		keepEvaluating = keepEvaluating,
		doesIgnoreCase = doesIgnoreCase
	}
	table.insert(entityFilters, filter)
end

local function setFilter(i, filter)
	-- 1. Set the regex pattern.
	local msg = [[Enter a regular expression to check against the living thing name.

If there are multiple identical things in the room, their text will start with a number.
i.e. "2 annoying children".
Certain colored things with 'and' in their name will become hyphenated.
i.e. "grey-and-white spaniel"
Capitalization is preserved, but you can set the regex to be case-insensitive.]]
	local extras = { box_width = 800, box_height = 250, prompt_height = 100 }
	local default = filter and filter.pattern
	local pattern = utils.editbox(msg, "Define RegEx", default, nil, nil, extras)
	if not pattern then  return  end

	-- 2. Set the score.
	local msg = [[Enter your desired score number.]]
	local default = filter and filter.score or 1
	local score = utils.inputbox(msg, "Select Score", default)
	if not score then  return  end
	score = tonumber(score)
	if not score then  Note("Invalid score. Must be a number. Aborting.")  return  end

	-- 3. Set 'keepEvaluating'.
	local msg = [[Should we keep evaluating if this filter matches?
i.e. should subsequent filters be able to override this one?]]
	local default = filter and (filter.keepEvaluating and 1 or 2) or 2
	local keepEvaluating = utils.msgbox(msg, "Keep Evaluating?", "yesno", "?", default)
	if not keepEvaluating then  return  end
	keepEvaluating = keepEvaluating == "yes" and true or nil

	-- 4. Set 'doesIgnoreCase'
	local msg = [[Is the regex pattern case-sensitive?]]
	local default = filter and (filter.doesIgnoreCase and 2 or 1) or 1
	local doesIgnoreCase = utils.msgbox(msg, "Case-sensitive?", "yesno", "?", 1)
	if not doesIgnoreCase then  return  end
	doesIgnoreCase = doesIgnoreCase == "no" and true or nil

	if filter then
		local regexFlags = doesIgnoreCase and CASE_INSENSITIVE or nil
		filter.regex = rex.new(pattern, regexFlags)
		filter.pattern = pattern
		filter.score = score
		filter.keepEvaluating = keepEvaluating
		filter.doesIgnoreCase = doesIgnoreCase
	else
		addFilter(pattern, score, group, keepEvaluating, doesIgnoreCase)
	end
end

local function chooseFilter(msg, title)
	local list = {}
	for i,f in ipairs(entityFilters) do
		local str = i .. ": " .. f.pattern .. ", " .. tostring(f.score) .. ", "
		str = str .. tostring(not not keepEvaluating) .. ", " .. tostring(not doesIgnoreCase)
		table.insert(list, str)
	end

	return utils.listbox(msg, title, list), list -- Return the filter index.
end

local function modifyFilter()
	local filterIdx = chooseFilter("", "Choose a Filter to Modify")
	if filterIdx then
		setFilter(nil, entityFilters[filterIdx])
	end
end

local function deleteFilter()
	local filterIdx, list = chooseFilter("", "Choose a Filter to Delete")
	if filterIdx then
		local idStr = list[filterIdx]
		local msg = "Are you sure you want to delete the filter:\n" .. idStr
		local confirm = utils.msgbox(msg, "Really Delete?", "okcancel")
		if confirm == "ok" then
			table.remove(entityFilters, filterIdx)
		end
	end
end

local function setFilterOrder()
	local filterIdx = chooseFilter("", "Choose a Filter to Reorder")
	if filterIdx then
		local minI, maxI = 1, #entityFilters
		local list = {}
		for i=minI,maxI do  list[i] = i  end
		local toIdx = utils.choose("", "Choose a New Index", list, filterIdx)
		if toIdx then
			local filter = entityFilters[filterIdx]
			table.remove(entityFilters, filterIdx)
			table.insert(entityFilters, toIdx, filter)
		end
	end
end

-- MDT Data Handling:
--------------------------------------------------
local function toggleMDTIndicators(i)
	MDTIndicatorsEnabled = not MDTIndicatorsEnabled
	window.checkMenuItem(winID, i, MDTIndicatorsEnabled)
	refresh()
end

local function scoreMDTRooms(data)
	for i,room in ipairs(data) do
		local score = 0
		for i,entStr in ipairs(room.entities) do
			local _, _, capt = getCountRegex:match(entStr)
			local count = capt and capt[1] or 1
			local entScore = 1
			for i,filter in ipairs(entityFilters) do
				if filter.regex:match(entStr) then
					entScore = filter.score
					if not filter.keepEvaluating then  break  end
				end
			end
			score = score + entScore*count
		end
		room.score = score
	end
end

-- Make a 2D array of room scores with relative coordinates from player.
local function makeMDTArraymap(data)
	local map = {}
	for i,room in ipairs(data) do
		local x, y = room.dx, room.dy
		map[y] = map[y] or {}
		map[y][x] = room.score or 1
	end
	data.scoreMap = map
end

-- Right-Click Menu Handling:
--------------------------------------------------
local function pickFont()
	local fnt = utils.fontpicker(fontFamily, fontSize)
	if fnt then
		fontFamily, fontSize = fnt.name, fnt.size
		loadFont(winID, fontID, fontFamily, fontSize)
		window.draw(winID)
	end
end

local function pickColor(i, colorName)
	local result = PickColour(COLORS[colorName])
	if result ~= -1 then
		COLORS[colorName] = result
		refresh()
	end
end

local function resetColorToDefault(i, colorName)
	COLORS[colorName] = DEFAULT_COLORS[colorName]
	refresh()
end

local function setSpacing(i, axis)
	local curSpacing = axis == "X" and spacingX or spacingY
	local msg = "Enter your desired " .. axis .. " spacing."
	local title = "Set " .. axis .. " Spacing"
	local newSpacing = utils.inputbox(msg, title, curSpacing)
	if not newSpacing then  return  end
	newSpacing = tonumber(newSpacing)
	if not newSpacing then  Note("Invalid spacing. Must be a number. Aborting.")  return  end
	if axis == "X" then
		spacingX = newSpacing
		window.setMenuItem(winID, 2, "Set X spacing...(cur: "..spacingX..")")
	else
		spacingY = newSpacing
		window.setMenuItem(winID, 3, "Set Y spacing...(cur: "..spacingY..")")
	end
	refresh()
end

local menuItems = {}

local function menuItem(text, fn, ...)
	table.insert(menuItems, {text, fn, ...})
end

menuItem("Set font...", pickFont)
menuItem("Set X spacing...(cur: "..spacingX..")", setSpacing, "X")
menuItem("Set Y spacing...(cur: "..spacingY..")", setSpacing, "Y")
local colorNames = {"background", "border", "Normal", "Yellow", "Red", "Green", "Cyan", "Blue", "Desert", "Magenta", "White"}
menuItem(">Colors:")
menuItem(">Defaults:")
for i,colorName in ipairs(colorNames) do
	menuItem("Reset "..colorName.." to default", resetColorToDefault, colorName)
end
menuItem("<")
menuItem("-")
for i,colorName in ipairs(colorNames) do
	menuItem("Set "..colorName.." color...", pickColor, colorName)
end
menuItem("<")
menuItem(">Living thing indicators:")
menuItem("+Enabled", toggleMDTIndicators) -- Change the toggle on init, after settings are loaded.
local MDTEnabledMenuIndex = #menuItems
menuItem("-")
menuItem("Show filter list...", modifyFilter)
menuItem("Add filter...", setFilter)
menuItem("Modify filter...", modifyFilter)
menuItem("Delete filter...", deleteFilter)
menuItem("Change filter order...", setFilterOrder)
menuItem("<")

local menuItemList = {} -- List of button texts for adding to window.
for i,v in ipairs(menuItems) do  table.insert(menuItemList, v[1])  end

local function menuItemClicked(winID, i, prefix, item)
	local data = menuItems[i]
	if data then
		local fn = data[2]
		fn(i, unpack(data, 3))
	end
end

-- GMCP Parsing:
--------------------------------------------------
local function processColorCodes(startPos, line, lineIdx)
	-- Strip out color codes and record at which character index the color changes.
	local startI, endI, captures = mxpColorRegex:match(line, startPos)
	if endI then
		local colorName = captures[1]

		if colorName == "Yellow" then -- This is the line the player is on.
			playerX, playerY = startI, lineIdx
		end

		-- Convert color string into an integer RGB value.
		local colorInt
		if COLORS[colorName] then
			colorInt = COLORS[colorName]
		else
			local _s, _e, hexCaptures = hexRegex:match(colorName)
			if hexCaptures then
				if hexCaptures[1] == "#ff8700" then
					colorName = "Desert"
					colorInt = COLORS[colorName]
				else
					colorInt = ColourNameToRGB(hexCaptures[1]) -- ColourNameToRGB will convert hex colors.
				end
			else
				Note("RossAsciiMap - Unrecognized color code: '", string.sub(line, startI, endI), "'.")
				colorInt = COLORS.Normal
			end
		end
		colorChangesAt[lineIdx] = colorChangesAt[lineIdx] or {}
		colorChangesAt[lineIdx][startI] = colorInt

		-- Cut color code chunk out of map string.
		local pre = string.sub(line, 1, startI - 1)
		local post = string.sub(line, endI + 1)
		line = pre .. post
	end
	-- We're removing everything from startI to endI, so our startI should
	-- also be the start for the next match.
	return startI, line
end

--[[
-- Output from MUD:
"\u001b[3z\u001b[4zMXP<RedMXP>+\u001b[3z     \u001b[3z\u001b[4zMXP<RedMXP>+\u001b[3z   \n\u001b[3z\u001b[4zMXP<GreenMXP>&\u001b[3z-\u001b[3z\u001b[4zMXP<CyanMXP>*\u001b[3z-\u001b[3z\u001b[4zMXP<YellowMXP>@\u001b[3z-\u001b[3z\u001b[4zMXP<GreenMXP>$\u001b[3z   \n       \u001b[3z\\\u001b[3z  \n        \u001b[3z\u001b[4zMXP<CyanMXP>*\u001b[3z-\u001b[3z\n"
-- Desired Result:
+     +
&-*-@-$
       \
        *-
--]]

function onGMCPReceived(message, dataStr)
	if message == "room.writtenmap" then
		lastMDTPacket = dataStr
		if MDTIndicatorsEnabled then
			curMDTData = parseMDT(dataStr)
			scoreMDTRooms(curMDTData)
			makeMDTArraymap(curMDTData)
		end
		window.draw(winID) -- writtenmap is sent second, so draw here.
	elseif message == "room.map" then
		-- Map is colored with MXP color codes. First strip out the extra junk, then split into lines and process the color codes.
		lastMapPacket = dataStr
		local map = dataStr
		map = string.sub(map, 2, -2) -- remove surrounding quotes ("").
		map = string.gsub(map, "\\u001b%[4z", "") -- Remove ANSI codes before MXP colors.
		map = string.gsub(map, "MXP<[\\/]-send.-MXP>", "") -- remove MXP links, if any (not colors).
		-- Replace ANSI reset code with a fake MXP color tag, which the next step will pick up.
		map = string.gsub(map, "\\u001b%[3z", "MXP<NormalMXP>")
		-- Un-escape actual map characters.
		map = string.gsub(map, "\\\\", "\\") -- change \\ to \.
		map = string.gsub(map, "\\\/", "\/") -- change \/ to /.

		for i=#mapLines,1,-1 do -- Clear old lists.
			mapLines[i] = nil
			colorChangesAt[i] = nil
		end

		for line in string.gmatch(map, "(.-)\\n") do -- Split map up into lines.
			table.insert(mapLines, line)
		end

		for lineIdx,line in ipairs(mapLines) do
			local startPos = 1
			while startPos do
				startPos, line = processColorCodes(startPos, line, lineIdx)
			end
			mapLines[lineIdx] = line -- Update line after stripping out color codes.
		end
	end
end

-- Drawing:
--------------------------------------------------
local function drawWindow()
	winRect.width = WindowInfo(winID, 3)
	winRect.height = WindowInfo(winID, 4)
	WindowRectOp(winID, 2, 0, 0, winRect.width, winRect.height, COLORS.background) -- Clear/Fill Background
	WindowRectOp(winID, 1, 0, 0, winRect.width, winRect.height, COLORS.border) -- Draw Border

	local gridX, gridY = fontCharWidth + spacingX, fontHeight + spacingY

	local mapHalfWidth = (playerX - 0.5) * gridX
	local mapHalfHeight = (playerY - 0.5) * gridY

	local ox, oy = winRect.width/2 - mapHalfWidth, winRect.height/2 - mapHalfHeight

	local baseCol = COLORS.Normal
	local color = baseCol
	for lineIdx,line in ipairs(mapLines) do
		local x, y = ox, oy + (lineIdx - 1)*gridY
		color = baseCol

		for charIdx=1,string.len(line) do
			if colorChangesAt[lineIdx] and colorChangesAt[lineIdx][charIdx] then
				color = colorChangesAt[lineIdx][charIdx]
				if type(color) ~= "number" then
					Note("RossAsciiMap - Weird color value in colorChangesAt: ", colorChangesAt[lineIdx][charIdx])
					color = COLORS.Normal
				end
			end
			local char = string.sub(line, charIdx, charIdx)
			if char ~= " " then
				WindowText(winID, fontID, char, x, y, x+fontMaxCharWidth, y+gridY, color)
			end
			x = x + gridX
		end
	end

	-- Draw room scores.
	if MDTIndicatorsEnabled and curMDTData then
		local ox, oy = winRect.width/2, winRect.height/2 -- Start from player pos, center of window.
		for dy,row in pairs(curMDTData.scoreMap) do
			for dx,score in pairs(row) do
				-- Double dx and dy because rooms are every-other line on the ASCII map.
				local x, y = ox + dx*2*gridX, oy - dy*2*gridY -- Subtract dy because we draw in +y = down coordinates.
				x = x + 2
				WindowText(winID, fontID, score, x, y, x+fontMaxCharWidth, y+gridY, COLORS.Red)
			end
		end
	end
end

-- Setup & Breakdown:
--------------------------------------------------
function loadFont(winID, fontID, fontFamily, fontSize) -- Is local--upvalue defined above.
	WindowFont(winID, fontID, fontFamily, fontSize, nil, nil, nil, nil, 0)
	fontHeight = WindowFontInfo(winID, fontID, 1)
	fontCharWidth = WindowFontInfo(winID, fontID, 6) -- Average character width.
	fontMaxCharWidth = WindowFontInfo(winID, fontID, 7) -- Max character width.
end

local function init()
	CallPlugin(GMCP_INTERFACE_ID, "subscribe", SELF_ID, "onGMCPReceived", "room.map", "room.writtenmap")
	loadSettings()
	window.new(
		winID, winRect.x, winRect.y, winRect.width, winRect.height, winRect.z,
		nil, nil, nil, true, winLocked, menuItemClicked, drawWindow
	)
	window.addMenuItems(winID, 1, menuItemList)
	if not MDTIndicatorsEnabled then
		window.checkMenuItem(winID, MDTEnabledMenuIndex, MDTIndicatorsEnabled)
	end
	loadFont(winID, fontID, fontFamily, fontSize)
	refresh()
end

local function final()
	winRect.x, winRect.y, winRect.width, winRect.height, winRect.z = window.getRect(winID)
	winLocked = window.getLocked(winID)
	WindowDelete(winID)
	CallPlugin(GMCP_INTERFACE_ID, "unsubscribe", SELF_ID, "room.map", "room.writtenmap")
end

function OnPluginInstall()  init()  end
function OnPluginEnable()  init()  end
function OnPluginClose()  final()  end
function OnPluginDisable()  final() end

	]]>
</script>

</muclient>
